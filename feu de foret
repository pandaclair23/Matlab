%{
--------------------------------------------------------------------------------------------------
 PIRLOT
 Marie-Alix
 16/12/2022
--------------------------------------------------------------------------------------------------
%}

% On ferme toutes les fenÃªtres et on supprime toutes les variables gÃ©nÃ©rÃ©es prÃ©cÃ©demment
close all
clear variable
clc

disp('Au feu!');

N=input('taille du plateau:');

%{
On crÃ©e une matrice carrÃ©e de zÃ©ros de taille NxN qui servira Ã  attribuer les valeurs 2 puis 3 aux
arbres de la matrice "trees". En effet, la matrice suivante ("trees") est une matrice de 0 et de 1
gÃ©nÃ©rÃ©s alÃ©atoirement. Cette matrice ne peut donc pas contenir de 2. Pour contrer cela, on crÃ©e
une matrice de 0 ("fields") dans laquelle on modifiera directement les valeurs de 0 en 2 ou 3.
%}
fields=zeros(N);

% On crÃ©e une matrice carrÃ©e de taille NxN contenant des zÃ©ros (0) et des uns (1) gÃ©nÃ©rÃ©s
% alÃ©atoirement. La quantitÃ© de 1 gÃ©nÃ©rÃ©s dÃ©pend de la densitÃ© choisie.
density=input('entrer le choix de la densitÃ©:');
trees=rand(N)>density;

% On superpose la matrice contenant des 1 et celle ne contenant que des 0 (pour le moment). Cette
% superposition permet d'attribuer les futures nouvelles valeurs de "fields" Ã  "trees".
trees=trees+fields;

%{
On va crÃ©er une boucle ğ™¬ğ™ğ™ğ™¡ğ™š qui va nous permettre de trouver l'arbre d'oÃ¹ va partir le feu.
Pour cela, on doit trouver une coordonnÃ©e de la matrice Ã  laquelle correspond la valeur a=1
(un arbre). La boucle va donc tourner tant qu'elle tombe sur a=0 jusqu'Ã  trouver un a=1.
%}
a=0;
while a==0
%{
Pour la suite, on a besoin de gÃ©nÃ©rer deux nombres alÃ©atoires qu'on utilisera pour dÃ©terminer
alÃ©atoirement les coordonneÃ©s du 1er arbre en feu. Les arbres en feu vont correspondre Ã  la valeur 2.
ğ™§ğ™–ğ™£ğ™™ ne gÃ©nÃ¨re des valeurs comprises qu'entre 0 et 1. On va donc utiliser ğ™§ğ™–ğ™£ğ™™ğ™ pour gÃ©nÃ©rer deux
nombres alÃ©atoires (i et j) compris entre 2 et N-1 (en l'ocurrence, N-1 = 49).
%}
i=randi([2,N-1]);
j=randi([2,N-1]);
%{
On regarde la valeur de a en coordonnÃ©es (i,j). Lorsqu'on tombe sur a=1, on va changer sa valeur
en a=2 (arbre en feu).
%}
a=trees(i,j);
    if a==1
    trees(i,j)=2;
    end
end

%{
Une nouvelle boucle ğ™¬ğ™ğ™ğ™¡ğ™š va nous permettre de propager le feu ainsi que de changer les arbres
"en feu" en arbres "brulÃ©s".
Pour ce faire, on va crÃ©er une matrice "treesv2" identique Ã  "trees" qui nous servira Ã  mettre Ã 
jour les valeurs de notre matrice.
%}
t=true;
treesv2=trees;
while t
%{
On va utiliser les coordonnÃ©es (c,d) pour naviguer dans notre matrice "trees". c et d vont balayer
toute la matrice jusqu'Ã  trouver notre 1er arbre en feu. Une fois sa position (coordonnÃ©es) trouvÃ©e,
sa valeur 2 correspondante (dans "trees") va Ãªtre dÃ©finie comme Ã©tant 3 Ã  cette mÃªme position 
dans "treesv2".
Ensuite, on va regarder les quatre cellules autour de cette position. Si ce sont des arbres 
(valeur 1), ils prendront feu. Sinon, les cellules resteront des prairies (valeur 0). Ici le
mÃ©canisme est le mÃªme que prÃ©cÃ©demment : c'est dans "trees" que l'on cherche les arbres (valeur 1),
et dans "treesv2" que l'on dÃ©finit la nouvelle valeur "en feu" (2).
Ã€ chaque fois que les valeurs autour d'un arbre tout juste brulÃ© sont mises Ã  jour, les valeurs de
"treesv2" sont apliquÃ©es Ã  "trees", et on recommence jusqu'Ã  ce que les matrices soient les mÃªmes
(plus d'arbres Ã  brÃ»ler).
%}
for c=2:N-1
    for d=2:N-1
        if trees(c,d)==2
            treesv2(c,d)=3;
            if trees(c-1,d)==1
                treesv2(c-1,d)=2;
            end
            if trees(c,d-1)==1
                treesv2(c,d-1)=2;
            end
            if trees(c+1,d)==1
                treesv2(c+1,d)=2;
            end
            if trees(c,d+1)==1
                treesv2(c,d+1)=2;
            end
        end
    end
end

if treesv2==trees
    t=false;
else 
   trees=treesv2;
end
%{
"mymap" contient des codes couleur RVB (Rouge, Vert, Bleu) (ou RGB en anglais). Blanc pour les 0,
vert pour les 1, rouge pour les 2 et noir pour les 3, de la matrice "treesv2".
ğ™ğ™¢ğ™–ğ™œğ™šğ™¨ğ™˜ affiche la figure de la matrice "treesv2".
C'est ğ™˜ğ™¤ğ™¡ğ™¤ğ™§ğ™¢ğ™–ğ™¥ qui va attribuer les codes RVB de "mymap" aux valeurs de "treesv2" et ainsi
colorer les cellules de la figure en fonction de leur valeur respective.
ğ™™ğ™§ğ™–ğ™¬ğ™£ğ™¤ğ™¬ met Ã  jour la figure en direct (pour qu'on voie l'Ã©vulotion du feu en temps rÃ©el).
%}
mymap = [1 1 1;0 1 0;1 0 0;0 0 0];
imagesc(treesv2)
colormap(mymap)
drawnow
end
%{
Cette derniÃ¨re "mymap" permet de "corriger" les arbres rouges restants sur les bords de la figure
en les forÃ§ant Ã  se colorer en noir. Pour cela, on vient juste enlever le code RVB de la couleur
rouge de la "mymap" de la derniÃ¨re image de la figure de "treesv2" de sorte Ã  ce que les valeurs
2 prennent la couleur noire (et Ã©galement les valeurs supÃ©rieures Ã  2 car notre "mymap" ne dÃ©finit
pas de couleur pour ces derniÃ¨res). Ceci est purement esthÃ©tique et vient remÃ©dier Ã  une limite du
code.
%}
mymap = [1 1 1;0 1 0;0 0 0];
imagesc(treesv2)
colormap(mymap)
drawnow
